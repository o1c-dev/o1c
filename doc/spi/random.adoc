= Random Bit Generator

Many cryptographic algorithms require cryptographically secure random data.
These random data come from two classes of random bit generators (RBGs): non-deterministic RBGs and deterministic RBGs.
Non-deterministic RBGs typically incorporate hardware components that use measurements of the physical environment.
Deterministic random bit generators, or DRBGs, on the other hand, produce a deterministic output given the same seed.
DRBGs typically use either a hash or cipher function on top of non-deterministic entropy gathering to seed itself.

== Deterministic Random Bit Generator

O(1) Cryptography provides DRBGs based on https://doi.org/10.6028/NIST.SP.800-90Ar1[NIST SP 800-90A rev1] with perfect forward secrecy using ratcheting and automatic reseeding.
The primary implementation is based on BLAKE3 comparable to the HMAC_CTR strategy.
Random data are generated for various cryptographic uses via thread-safe DRBGs through the following SPI.

.C SPI
[source,c]
----
void drbg_randombytes(void *buf, unsigned long bytes);
----

.Java SPI
[source,java]
----
public interface RandomBytesGenerator {
    byte[] generateBytes(int nrBytes);
}
----

== Seeds and Entropy

Seeds are used to initialize and reinitialize instances of deterministic random bit generators (DRBGs) with entropy.
For example, a DRBG based on a stream cipher with _s_ bytes of internal state can be seeded with _s_ bytes of entropy.
Operating systems provide various low level APIs for obtaining system entropy, and these sources are exposed through the following SPI.

.C SPI
[source,c]
----
void drbg_entropy(void *buf, unsigned long bytes);
----

.Java SPI
[source,java]
----
public interface SeedGenerator {
    byte[] generateSeed(int nrBytes);
}
----
